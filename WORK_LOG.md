Name: YOUR NAME HERE

| Date   |         Time         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Update |
|:-------|:--------------------:|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Sept 2 | A Block (15 minutes) |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Talked with Logan and Alberto about how to tackle the problem. We settled on the fact that you would need to work backwards from the final spot. |
| Sept 3 |   Started at 11:05   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Thought to self using deep reflection and came up with baller idea. Basically work backwards and create a ladder score for each ladder, which is equal to (ceiling(length of ladder / 6) - ceiling(distance from player / 6)). The ladder with the highest score is the most efficient pick. Yippee! Time to try code it to test it out. |
|        |       11:30ish       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Okay, I've coded most of what I think I'll need. I'm debugging though, because I returned 2 for the first test when it should be 3. My approach is to use some print statements, so for each time I'm moving my character, I print out the current position, the roll counter, and the position of the next targeted ladder |
|        |       11:40ish       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Okay, my code worked for test 0, but not for test 6 (amongst others). but now i'm confused, becasue I read through the data for test 6 and it has a ladder from 3->5, and from 9->99, and since 99 is the last spot, okay now that im typing this im realizing maybe i should code my stuff from 1-100 instead of 0-99 whoops |
|        |    Ended at 12:15    | Okay I did that and then I did a LOT of analysis of my errors and i'm now realizing that I have to start factoring in snakes as a tool here. I don't have the time to code this, but my idea is that basically alongside considering the traditional ladder score I can also consider one where instead of only considering ladders that end sooner than the position of the player (im working backwards here), I'll consider every ladder, and if the ladder is a negative distance from the player (they would need to backtrack to reach it), i'll run a subprogram that sees if there's a route to the top of that ladder via snakes. If there is, it'll calculate the rolls needed to use the snake to reach that ladder, and then factor that into a revamped ladder score! This ladder score will be compared will all other ladder scores (traditional for ladders below; revamped for ladders above). If a backwards ladder has the best score despite requiring a snake-detour to reach, the simulated player will run thru the snakes route. Yay! I think this is a good idea. |
| Sept 7 |         4:30         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Okay following the discussion of graph theory I am going to approach the problem by making a graph full of nodes. I'll make a node class, that'll contain various instance variables (number, visited <bool>, destination <snake/ladder>), and also an arraylist of the connected nodes to the given node. I'll then use breadth first search to find the fastest path |
|        |         4:50         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Okay, I cranked all of that out except for the search part, because im seeing that I should make a new class to abstract away the BFS part of this. |
|        |         5:30         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Okay, so at first I accidentally coded depth first search. Whoops! I was just using pure recursion instead of incorporating a data structure. I looked back at my MazeSolver code and realized I needed to use a queue, so then I used one for this problem in my searcher.java class. After debugging errors, my algorithm predicts just slightly off from the correct value. |
|        |         5:35         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Huzzah! I figured out one error that was causing problems. I have a boolean for each node to record whether or not the node has been visited. For a snake or ladder origin node, I would essentially skip that node and instead add the destination of the snake/ladder to the queue, and set the destination as visited, yadayadayada. Except, I never actually set the initial origin node as visited. So I added that now! |


To add a new row to the table, click into a cell and then hit shift-enter.